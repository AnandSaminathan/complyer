--    //wants_to_enter[] is boolean array; and turn is an integer
--    wants_to_enter[1] = false
--        wants_to_enter[2] = false
--            turn    = 1   // or 2
--
--            P1:
--p1:wants_to_enter[1] = true;
--p2:while (wants_to_enter[2] == true) {
--p3:   if (turn ≠ 1) {
--p4:      wants_to_enter[1] = false;
--p5:      while (turn ≠ 1) {
--                      // busy wait
--                    
--         }
--p6:      wants_to_enter[1] = true;
--               
--      }
--         
--   }
--
--p7:// critical section
--   ...
--      turn    = 2;
--p8:wants_to_enter[1] = false;
--   // remainder section
--
--
--
--P2:
--q1:wants_to_enter[2] = true;
--q2:while (wants_to_enter[1] == true) {
--q3:   if (turn ≠ 2) {
--q4:      wants_to_enter[2] = false;
--q5:      while (turn ≠ 2) {
--                      // busy wait
--                    
--         }
--q6:      wants_to_enter[2] = true;
--               
--      }
--         
--   }
--
--q7:// critical section
--   ...
--      turn    = 1;
--q8:wants_to_enter[2] = false;
--   // remainder section
--


MODULE main

VAR p : integer;
VAR q : integer;
VAR wants_to_enter1 : boolean;
VAR wants_to_enter2 : boolean;
VAR turn : integer;


ASSIGN

init(p) := 1;
init(q) := 1;
init(wants_to_enter1) := false;
init(wants_to_enter2) := false;
init(turn) := 1;

next({p, wants_to_enter1}) := (p == 1 && wants_to_enter1 == false) [u1]: {2, true};
next({p, wants_to_enter2}) := (p == 2 && wants_to_enter2 == false) [u2]: {7, false};
next({p, wants_to_enter2}) := (p == 2 && wants_to_enter2 == true)  [u3]: {3, true};
next({p, turn}) := (p == 3 && turn == 1) [u4]: {2, 1};
next({p, turn}) := (p == 3 && turn == 2) [u5]: {4, 2};
next({p, wants_to_enter1}) := (p == 4 && wants_to_enter1 == true) [u6]: {5, false};
next({p, turn}) := (p == 5 && turn == 1) [u7]: {6, 1};
next({p, turn}) := (p == 5 && turn == 2) [u8]: {5, 2};
next({p, wants_to_enter1}) := (p == 6 && wants_to_enter1 == false) [u9]: {2, true};
next({p, turn}) := (p == 7 && turn == 1) [u10]: {8, 2};
next({p, turn}) := (p == 7 && turn == 2) [u11]: {8, 2};
next({p, wants_to_enter1}) := (p == 8 && wants_to_enter1 == true) [u12]: {1, false}; 


next({q, wants_to_enter2}) := (q == 1 && wants_to_enter2 == false) [v1]: {2, true};
next({q, wants_to_enter1}) := (q == 2 && wants_to_enter1 == false) [v2]: {7, false};
next({q, wants_to_enter1}) := (q == 2 && wants_to_enter1 == true)  [v3]: {3, true};
next({q, turn}) := (q == 3 && turn == 1) [v4]: {4, 1};
next({q, turn}) := (q == 3 && turn == 2) [v5]: {2, 2};
next({q, wants_to_enter2}) := (q == 4 && wants_to_enter2 == true) [v6]: {5, false};
next({q, turn}) := (q == 5 && turn == 1) [v7]: {5, 1};
next({q, turn}) := (q == 5 && turn == 2) [v8]: {6, 2};
next({q, wants_to_enter2}) := (q == 6 && wants_to_enter2 == false) [v9]: {2, true};
next({q, turn}) := (q == 7 && turn == 1) [v10]: {8, 1};
next({q, turn}) := (q == 7 && turn == 2) [v11]: {8, 1};
next({q, wants_to_enter2}) := (q == 8 && wants_to_enter2 == true) [v12]: {1, false}; 

SAFETYSPEC
!(p == 7 && q == 7)
